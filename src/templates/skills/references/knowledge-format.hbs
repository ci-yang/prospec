# AI Knowledge Format Reference

This document describes the AI Knowledge format and usage patterns, referenced by all Skills.

---

## AI Knowledge Structure

```
{{knowledge_base_path}}/
├── _index.md                    # Overview: module list, keyword index, available files
├── _conventions.md              # Project-wide coding conventions
├── raw-scan.md                  # CLI scan data (input for knowledge generation)
└── modules/
    ├── {module-1}/
    │   ├── README.md            # Overview: responsibilities, design decisions
    │   ├── api-surface.md       # Public API: export signatures, types
    │   ├── dependencies.md      # Dependency analysis: import graph, packages
    │   └── patterns.md          # Code patterns: error handling, naming
    ├── {module-2}/
    │   ├── README.md
    │   ├── api-surface.md
    │   └── dependencies.md
    └── {module-3}/
        └── README.md
```

**Note:** Not all modules need all file types. Check `_index.md` Files column for available files per module.

---

## 1. `_index.md` Format

### Purpose

Provides a module overview and keyword index for the project, enabling quick identification of relevant modules.

### Standard Format

```markdown
# {{project_name}} - AI Knowledge Index

## Modules

| Module | Keywords | Status | Description | Files | Depends On |
|--------|----------|--------|-------------|-------|------------|
| [module-1] | keyword1, keyword2 | Active | [Brief description] | readme, api-surface, dependencies, patterns | - |
| [module-2] | keyword3, keyword4 | Active | [Brief description] | readme, api-surface | module-1 |
| [module-3] | keyword5, keyword6 | Deprecated | [Brief description] | readme | module-1, module-2 |
```

### Field Descriptions

- **Module:** Module name (links to corresponding README.md)
- **Keywords:** Tags for keyword matching (comma-separated)
- **Status:** Module status (Active, Deprecated, Planned)
- **Description:** Brief description of module functionality
- **Files:** Available knowledge files for this module (comma-separated: readme, api-surface, dependencies, patterns)
- **Depends On:** Other modules this depends on (comma-separated)

---

## 2. Module Knowledge Files

Each module can have multiple knowledge files. The `README.md` is always present; others are generated based on project type detection or `.prospec.yaml` `knowledge.files` config.

### Base Files (all project types)

| File | Purpose | When to Load |
|------|---------|-------------|
| `README.md` | Overview, responsibilities, design decisions | Always — start here |
| `api-surface.md` | Public functions, classes, types with signatures | When calling or extending module APIs |
| `dependencies.md` | Import graph, third-party packages, reverse deps | When assessing change impact |
| `patterns.md` | Error handling, naming, idioms specific to module | When writing new code in the module |

### Project-Type-Specific Files (auto-detected)

| File | Project Type | Purpose | When to Load |
|------|-------------|---------|-------------|
| `endpoints.md` | Backend API | HTTP/GraphQL routes, request/response schemas | When working with API endpoints |
| `components.md` | Frontend SPA | Component props, events, hooks, state stores | When composing or extending UI |
| `screens.md` | Mobile App | Screen navigation, native bridges, platform diffs | When building screen flows |

### 2a. `modules/{module}/README.md` Format

#### Purpose

Provides detailed documentation for a single module, including overview, file listing, API, and internal notes.

### Standard Format

```markdown
# Module: {module-name}

## Overview

[1-2 paragraphs describing the module's functionality, purpose, and design principles]

---

## Key Files

- **src/{module}/index.ts**: [File purpose]
- **src/{module}/core.ts**: [File purpose]
- **src/{module}/utils.ts**: [File purpose]

---

## Public API

### Function: functionName(param1, param2)

**Description:** [Functionality description]

**Parameters:**
- `param1` (Type): [Parameter description]
- `param2` (Type): [Parameter description]

**Returns:** (Type) [Return value description]

**Example:**
```{{tech_stack.language}}
// Usage example
const result = functionName(value1, value2);
```

---

### Class: ClassName

**Description:** [Class description]

**Methods:**
- `method1(param)`: [Method description]
- `method2(param)`: [Method description]

**Example:**
```{{tech_stack.language}}
// Usage example
const instance = new ClassName();
instance.method1(value);
```

---

## Internal Notes

### Design Decisions

- [Design decision 1]
- [Design decision 2]

### Known Issues

- [Known issue 1]
- [Known issue 2]

### Future Improvements

- [Future improvement 1]
- [Future improvement 2]
```

---

## 3. Content Markers

AI Knowledge uses special markers to distinguish auto-generated and manually maintained content:

### Auto-Generated Content

```markdown
<!-- prospec:auto-start -->
[Auto-generated content, will be overwritten by tools]
<!-- prospec:auto-end -->
```

### User-Maintained Content

```markdown
<!-- prospec:user-start -->
[User manually maintained content, will not be overwritten by tools]
<!-- prospec:user-end -->
```

---

## 4. Progressive Disclosure Usage

**Load AI Knowledge progressively — avoid loading all files at once:**

### Step 1: Read _index.md

Before starting any Story or task, read `{{knowledge_base_path}}/_index.md`:

- Understand the project's overall architecture
- Quickly locate relevant modules via keyword matching
- Check the **Files** column to know what knowledge is available per module
- Confirm module dependency relationships

### Step 2: Load Module Knowledge On Demand

Based on your task type, choose the right knowledge file:

| Task Type | Load First | Then If Needed |
|-----------|-----------|----------------|
| Understanding a module | `README.md` | — |
| Calling module APIs | `api-surface.md` | `README.md` for context |
| Assessing change impact | `dependencies.md` | `README.md` for overview |
| Writing new code | `patterns.md` | `api-surface.md` for interfaces |
| Working with API routes | `endpoints.md` | `api-surface.md` for service interfaces |
| Building UI components | `components.md` | `patterns.md` for conventions |
| Implementing screen flow | `screens.md` | `components.md` for shared widgets |
| Full module deep-dive | `README.md` | all available files |

Examples:
- Working on `error-handler` API integration → read `{{knowledge_base_path}}/modules/error-handler/api-surface.md`
- Adding new REST endpoint → read `{{knowledge_base_path}}/modules/api/endpoints.md`
- Building new page component → read `{{knowledge_base_path}}/modules/pages/components.md`
- Refactoring `api-middleware` → read `{{knowledge_base_path}}/modules/api-middleware/dependencies.md` first

### Step 3: Avoid Over-Loading

**Do not read all module files at once**, as this causes:
- Context overload (token waste)
- Judgment interference (irrelevant information)

Start with the most specific file for your task. Load additional files only when the first doesn't answer your question.

---

## Example Usage Flow

### Scenario: Implementing a "Unified Error Handling" Story

1. **Read _index.md:**
   - Discover relevant modules: `error-handler`, `api-middleware`, `logger`
   - Check Files column: `error-handler` has `readme, api-surface, patterns`

2. **Execute Tasks:**
   - Task 1: Implement `BaseError` → Read `{{knowledge_base_path}}/modules/error-handler/patterns.md` (error patterns) + `api-surface.md` (existing exports)
   - Task 2: Integrate API Middleware → Read `{{knowledge_base_path}}/modules/api-middleware/dependencies.md` (impact analysis)
   - Task 3: Update Logger → Read `{{knowledge_base_path}}/modules/logger/api-surface.md` (current interface)

3. **Avoid:**
   - Reading all module files at once (causes context overload)
   - Loading `dependencies.md` when you only need API signatures

---

## Reference Information

- Project name: `{{project_name}}`
- Tech stack: `{{tech_stack.language}}` + `{{tech_stack.framework}}`
- AI Knowledge path: `{{knowledge_base_path}}`
- Constitution file: `{{constitution_path}}`
